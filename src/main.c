#include "stm32f4xx.h"
#include "stm32f4_discovery.h"


int main(void)
{
  int i = 0;

  /* Initialize LEDs */
  STM_EVAL_LEDInit(LED3);
  STM_EVAL_LEDInit(LED4);
  STM_EVAL_LEDInit(LED5);
  STM_EVAL_LEDInit(LED6);

  /* Turn on LEDs */
  STM_EVAL_LEDOn(LED3);
  STM_EVAL_LEDOn(LED4);
  STM_EVAL_LEDOn(LED5);
  STM_EVAL_LEDOn(LED6);

  //INICIALIZANDO CLOCKS
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE); //HABILITOU O CLOCK NA PORTA
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE); //HABILITOU O CLOCK DO TIMER2
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); //HABILITOU O CLOCK DO TIMER1


  //INICIALIZA O GPIO DE SAIDA
  GPIO_InitTypeDef GPIO;
  GPIO.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9; // SETA PINOS 8 E 9 RECEBEM AMBOS AS CONFIGURAÇÕES DA ESTRUTURA
  GPIO.GPIO_Mode = GPIO_Mode_AF; //FUNCAO ALTERNATIVA PRA ESSE GPIO
  GPIO.GPIO_OType = GPIO_OType_PP; //(OUTPUT TYPE) PINOS EM PUSH-PULL
  GPIO.GPIO_PuPd = GPIO_PuPd_NOPULL; //SEM PULL-UP OU PULL-DOWN
  GPIO.GPIO_Speed = GPIO_Speed_100MHz; //FREQUENCIA MAXIMA PARA O PWM
  GPIO_Init(GPIOA, &GPIO); // ESSA FUNCAO INICIALIZA O GPIO COM A ESTRUTURA DEFINIDA ATÉ A LINHA PASSADA
  	  	  	  	  	  	   // O PORTA ESTÁ CONFIGURADA DE ACORDO COM A ESTRUTURA DE NOME "GPIO"

  //INICIALIZA O GPIO DE ENTRADA
  GPIO.GPIO_Pin = GPIO_Pin_0; // SETA PINO 0 PARA RECEBER AS CONFIGURAÇÕES DA ESTRUTURA
  GPIO.GPIO_Mode = GPIO_Mode_IN; //FUNCAO DE ENTRADA PRA ESSE PINO
  GPIO.GPIO_PuPd = GPIO_PuPd_NOPULL; //SEM PULL-UP OU PULL-DOWN
  // NAO USAMOS NA ENTRADA O _OType E _Speed PARA ENTRADAS

  //CONFIGURANDO FUNCAO ALTERNATIVA DAS PORTAS
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource8,GPIO_AF_TIM1); //CONF A PORTA PARA SERVIR AO TIMER1
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_TIM1); //CONF A PORTA PARA SERVIR AO TIMER1
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource0,GPIO_AF_TIM2); //CONF A PORTA PARA SERVIR AO TIMER2

  //CONFIGURAR O CONTADOR DO TIMER1
  TIM_TimeBaseInitTypeDef TIM; //ESTRUTURA TIM
  TIM.TIM_Prescaler = 28-1; //DIVIDE O CLOCK POR 28 ,OU SEJA, CLK'= 168MHz/28 = 6MHz
  TIM.TIM_Period = 300-1; //CONTA DE 0 A 299 ATÉ DAR O OVERFLOW DO TIMER1
  	  	  	  	  	  	  //DIVIDE 6MHz POR 300, DE FORMA A DAR UM CLOCK DE 20KHz
  TIM.TIM_CounterMode = TIM_CounterMode_Up; //CONTADOR CRESCENTE.
  TIM_TimeBaseInit(TIM1, &TIM); //TIM1 É INICIALIZADO COMO DESCRITO NESSA ESTRUTURA ATÉ AGORA.

  //CONFIGURAR CONTADOR DO TIMER 2 (UTILIZANDO A ESTRUTURA ACIMA)
  TIM.TIM_Prescaler = 84-1; //DIVIDE O CLOCK POR 84 ,OU SEJA, CLK'= 168MHz/84 = 2MHz (VALOR ARBITRADO DE 0.5us PARA LER A ENTRADA)
  TIM.TIM_Period = 40000-1; //CONTA DE 0 A 39999 ATÉ DAR O OVERFLOW DO TIMER1
    	  	  	  	  	  	//DIVIDE 6MHz POR 300, DE FORMA A DAR UM CLOCK DE 20KHz
  TIM.TIM_CounterMode = TIM_CounterMode_Up; //CONTADOR CRESCENTE (NAO PRECISA ESTAR AQUI, VISTO QUE JÁ FOI SETADO ACIMA)
  TIM_TimeBaseInit(TIM2, &TIM); //TIM2 É INICIALIZADO COMO DESCRITO NESSA ESTRUTURA ATÉ AGORA.

  //DEFINIR PWM SAIDA
  TIM_OCInitTypeDef OC;
  OC.TIM_OCMode = TIM_OCMode_PWM1; //SETA O TIPO DE PWM
  OC.TIM_OCPolarity = TIM_OCPolarity_Low; // O NIVEL INATIVO AQUI É O 'O'
  TIM_OC1Init(TIM1, &OC); //CONFIGURA O CANAL 1 DO PWM
  TIM_OC2Init(TIM1, &OC); //CONFIGURA O CANAL 2 DO PWM

  //SETA O PWM DE ENTRADA
  TIM_ICInitTypeDef IC;
  IC.TIM_Channel = TIM_Channel_1; //INDICA QUE O PWM DE ENTRADA CHEGA PELO CANAL 1
  TIM_ICInit(TIM2, &IC); //CONFIFGURA O CANAL1 DE ENTRADA

  //HABILITA OS CANAIS DE ENTRADA/SAIDA
  TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Enable); //LIGA O CANAL DE SAIDA 1 DO TIMER 1
  TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Enable); //LIGA O CANAL DE SAIDA 2 DO TIMER 1
  TIM_CCxCmd(TIM2, TIM_Channel_1, TIM_CCx_Enable); //LIGA O CANAL DE ENTRADA 1 DO TIMER 2

  //HABILITA OS TIMERS
  TIM_Cmd(TIM1, ENABLE); //HABILITA O TIMER1
  TIM_Cmd(TIM2, ENABLE); //HABILITA O TIMER2


  /* Infinite loop */
  while (1)
  {
	i++;
  }
}


/*
 * Callback used by stm32f4_discovery_audio_codec.c.
 * Refer to stm32f4_discovery_audio_codec.h for more info.
 */
void EVAL_AUDIO_TransferComplete_CallBack(uint32_t pBuffer, uint32_t Size){
  /* TODO, implement your code here */
  return;
}

/*
 * Callback used by stm324xg_eval_audio_codec.c.
 * Refer to stm324xg_eval_audio_codec.h for more info.
 */
uint16_t EVAL_AUDIO_GetSampleCallBack(void){
  /* TODO, implement your code here */
  return -1;
}
